<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:dj="http://dowjones.com/2014/dummy"
    version="1.0">

<xsl:output method="xml" encoding="UTF-8" indent="yes"/>

<xsl:key name="srcid" match="image" use="@src-id" />
<xsl:param name="subsection"></xsl:param>
<xsl:param name="region"></xsl:param>
<xsl:param name="issuetype"></xsl:param>

<xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'" />
<xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />

<xsl:template match="/article-doc">
<jpml>
    <xsl:attribute name="lang">
        <xsl:choose>
            <xsl:when test="@language = 'en-us'">en</xsl:when>
            <xsl:otherwise><xsl:value-of select="@language"/></xsl:otherwise>
        </xsl:choose>
    </xsl:attribute>
    <p id="identifier"><xsl:choose>
        <xsl:when test="contains(@id, '.')">
            <xsl:value-of select="substring-before(@id, '.')"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="@id"/>
        </xsl:otherwise>
    </xsl:choose></p>
    <p id="type"><xsl:value-of select="@type"/></p>
    <p id="flashline"><xsl:value-of select="@display-name"/></p>

    <p id="pubdate-string">
        <xsl:call-template name="formatDate">
          <xsl:with-param name="yyyy-mm-dd_HH_MM" select="@last-pub-date"/>
        </xsl:call-template>
    </p>

    <p id="pubdate"><xsl:value-of select="@last-pub-date"/></p>
    <p id="subsection"><xsl:value-of select="$subsection"/></p>
    <p id="region"><xsl:value-of select="$region"/></p>
    <p id="share-link"><xsl:value-of select="@url"/></p>

    <panel id="metadata">
        <p id="article-manifest" />
        <p id="media-bucket" />
    </panel>

    <!-- TODO: paid/free flag -->

    <p id="headline"><xsl:call-template name="headline"/></p>
    <p id="subhed"><xsl:value-of select="article/article-body/headline/deck"/></p>
    <p id="byline"><xsl:call-template name="article-byline" /></p>
    <p id="summary"><xsl:value-of select="summary/summary-body/p"/></p>

    <panel id="summary-image">
        <xsl:apply-templates select="summary"/>
    </panel>

    <!-- TODO: grab largest summary image if there are no article images? -->
    <!-- TODO: exclude images referenced in insets? -->
    <!-- TODO: exclude images wrapped in media@type=FLASH -->
    <!-- REDO: generate-id(.) = generate-id(key('srcid', @src-id)) and -->
    <panel id="article-image">
        <xsl:apply-templates select="article/article-body//image[@width &gt; 0 and @height &gt; 0]"/>
    </panel>

    <!-- TODO: will we need to merge the SB2/3/4 text with the SB1 media? -->
    <!-- TODO: collapse empty p tags? ignore leading p tags too. -->
    <panel id="body">
        <xsl:apply-templates select="article/article-body"/>
        <!-- We will insert a mark body bug in the last p or tagline element -->
    </panel>

    <!-- Barron's will need external links, insets too. -->

</jpml>
</xsl:template>

<xsl:template name="headline">
<xsl:choose>
  <xsl:when test="($region=&quot;US&quot; or $region=&quot;XAMLUS&quot; or $region=&quot;GERMANY&quot;) and summary/alt-summary-body[@destination-type=&quot;THIS-ART&quot; and starts-with(@page,&quot;|Mobile|&quot;)]/headline/main-hed">
    <xsl:value-of select="summary/alt-summary-body[@destination-type=&quot;THIS-ART&quot; and starts-with(@page,&quot;|Mobile|&quot;)]/headline/main-hed" />
  </xsl:when>
  <xsl:when test="($region=&quot;US&quot; or $region=&quot;XAMLUS&quot; or $region=&quot;GERMANY&quot; or $issuetype=&quot;NOW&quot;) and summary/summary-body/headline/main-hed">
     <xsl:value-of select="summary/summary-body/headline/main-hed" />
  </xsl:when>
  <xsl:otherwise>
     <xsl:value-of select="article/article-body/headline/main-hed" />
  </xsl:otherwise>
</xsl:choose>
</xsl:template>

<!-- Bylines looks like this:
    <byline type="SIGNED">By
        <phrase type="AUTHOR">Emily Chasan</phrase>
        <credit>Senior Editor</credit>
    </byline>
-->

<xsl:template name="article-byline">
    <xsl:for-each select="article/article-body/byline/node()">
        <xsl:choose>
            <xsl:when test="self::phrase[@type = &quot;AUTHOR&quot;]">
                <!--<a class="byline-author">
                    <xsl:attribute name="href">person:<xsl:value-of select="@topicid"/></xsl:attribute>
                    <xsl:value-of select="."/>
                </a>-->
                <span class="byline-author"><xsl:value-of select="."/></span>
            </xsl:when>
            <xsl:when test="self::credit">
                <span class="byline-credit"><xsl:value-of select="."/></span>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="."/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:for-each>
</xsl:template>

<xsl:template match="p[@type = &quot;CODA&quot;]" priority="1">
    <xsl:if test="string(.)">
        <panel class="blockquote"><p class="blockquote-p"><xsl:apply-templates select="node()"/></p></panel>
    </xsl:if>
</xsl:template>

<xsl:template match="p" priority="0">
    <xsl:if test="string(.)">
        <p>
            <xsl:if test="@type">
                <xsl:attribute name="class">
                    <xsl:value-of select="@type"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:choose>
                <xsl:when test="not(preceding-sibling::p[string(.) and position()=1])">
                    <xsl:attribute name="id">body-first-p</xsl:attribute>
                </xsl:when>
                <xsl:when test="not(following-sibling::p[position()=last()]) and not(following-sibling::tagline[position()=last()])">
                    <xsl:attribute name="id">body-last-p</xsl:attribute>
                </xsl:when>
            </xsl:choose>
            <xsl:if test="not(preceding-sibling::p[string(.) and position()=1])">
                <mark class="body-first-p-mark"/>
            </xsl:if>
            <xsl:apply-templates select="node()"/>
            <xsl:if test="not(following-sibling::p[position()=last()]) and not(following-sibling::tagline[position()=last()])">
                <mark class="body-last-p-mark"/>
            </xsl:if>
        </p>
        <!-- Insert banner ads on iPhone after the fourth paragraph. The panel reserves space so the box isn't cropped by the viewport. -->
        <xsl:if test="count(preceding-sibling::p) = 3">
            <panel class="hidden_tablet" id="ad_inline_panel">
                <p></p>
            </panel>
            <box id="ad_inline_outer" class="hidden_tablet">
                <box id="ad_inline_inner" embed="advertisement"></box>
            </box>
        </xsl:if>
    </xsl:if>
</xsl:template>

<xsl:template match="list[@type = &quot;UNORDERED&quot;]">
    <!--panel class="unordered-list"-->
        <xsl:apply-templates select="*"/>
    <!--/panel-->
</xsl:template>

<xsl:template match="list[@type = &quot;ORDERED&quot;]">
    <!--panel class="ordered-list"-->
        <xsl:apply-templates select="*"/>
    <!--/panel-->
</xsl:template>

<xsl:template match="list-item">
    <p class="list-item"><mark><xsl:choose>
        <xsl:when test="../@type = &quot;UNORDERED&quot;">
            <xsl:attribute name="class">list-item-bullet</xsl:attribute>
        </xsl:when>
        <xsl:when test="../@type = &quot;ORDERED&quot;">
            <xsl:attribute name="class">list-item-number</xsl:attribute>
            <xsl:value-of select="position()"/>
            <xsl:text>.</xsl:text>
        </xsl:when>
    </xsl:choose></mark><xsl:text> </xsl:text><xsl:apply-templates select="node()|@*"/></p>
</xsl:template>

<!-- We intentionally do not output the byline as part of the article body. -->
<xsl:template match="byline">
</xsl:template>

<xsl:template match="headline">
</xsl:template>

<xsl:template match="article-body">
    <xsl:apply-templates select="*"/>
</xsl:template>

<!-- Ignore all insets, unless they are "body continuation" insets -->
<!-- TODO: we should still grab article images from insets? -->
<xsl:template match="inset">
    <xsl:if test="@param1 = 'CONTINUATION'">
        <xsl:apply-templates/>
    </xsl:if>
</xsl:template>

<xsl:template match="highlight[@type='BOLD']">
    <strong><xsl:apply-templates select="*|node()"/></strong>
</xsl:template>

<xsl:template match="highlight[@type='ITALIC']">
    <em><xsl:apply-templates select="*|node()"/></em>
</xsl:template>

<!--
    Suppress tesla-style article links. Note: keep support for Methode style article links for decos.
    Example: http://online.wsj.com/news/articles/SB10001424052702303546204579442361298095276
-->
<xsl:template match="link[@type='EXTERNAL']">
    <xsl:apply-templates/>
</xsl:template>

<!--
    Suppress "speaking URLs" aka SEO links.
    Example: http://online.wsj.com/articles/heard-on-the-street-weibos-worth-is-hard-to-pin-down-1395060811
-->
<!-- <xsl:template match="link[@type='EXTERNAL' and starts-with(//article//nameloc[@id = current()/@linkend]/nmlist, 'http://online.wsj.com/articles/')]">
    <xsl:apply-templates/>
</xsl:template> -->

<!--
    Suppress blog links.
    Example: http://blogs.wsj.com/moneybeat/2014/03/16/old-bull-is-showing-its-age/
-->
<!-- <xsl:template match="link[@type='EXTERNAL' and starts-with(//article//nameloc[@id = current()/@linkend]/nmlist, 'http://blogs.wsj.com/')]">
    <xsl:apply-templates/>
</xsl:template> -->

<!--
    Suppress video links until 5.5.7 is out which fixes an issue with shebangs
    Example: http://live.wsj.com/#!272852E5-A606-4192-A4E1-95E4A9FEE29E
-->
<!-- <xsl:template match="link[@type='EXTERNAL' and starts-with(//article//nameloc[@id = current()/@linkend]/nmlist, 'http://live.wsj.com/')]">
    <xsl:apply-templates/>
</xsl:template> -->




<xsl:template match="link">
    <xsl:variable name="id" select="@linkend" />
    <a>
        <xsl:attribute name="class">
            <xsl:choose>
                <xsl:when test="@type='ARTICLE'">link-article</xsl:when>
                <xsl:when test="@type='EXTERNAL'">link-external</xsl:when>
                <xsl:otherwise>link-<xsl:value-of select="@icon"/></xsl:otherwise>
            </xsl:choose>
        </xsl:attribute>
        <xsl:attribute name="href">
            <xsl:choose>
                <!-- Old style linking to a file in the issue, here for historical purposes -->
                <xsl:when test="@icon = 'pdf-embedded-in-the-issue'">file:<xsl:call-template name="get_file_name">
                        <xsl:with-param name="input">
                            <xsl:call-template name="nameloc_by_id">
                                <xsl:with-param name="id" select="$id" />
                            </xsl:call-template>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:when>
                <!-- Mobile editorial curated section deco links in the form "wsj:/SECTION_NAME" should produce "/SECTION_NAME" -->
                <xsl:when test="starts-with(//article//nameloc[@id = $id]/nmlist, 'wsj:')">
                    <xsl:value-of select="substring(//article//nameloc[@id = $id]/nmlist, 5)" />
                </xsl:when>
                <!-- Otherwise, just use the link itself -->
                <xsl:otherwise>
                    <xsl:choose>
                        <!-- For articles, the link is a raw article identifier, e.g. SB123, so prepend "article" scheme -->
                        <xsl:when test="@type = 'ARTICLE'">article:</xsl:when>
                        <xsl:otherwise/>
                    </xsl:choose><xsl:call-template name="nameloc_by_id">
                        <xsl:with-param name="id" select="$id" />
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:attribute>
        <xsl:apply-templates select="*|node()"/>
    </a>
</xsl:template>

<xsl:template match="phrase">
    <xsl:value-of select="."/>
</xsl:template>

<!-- Person Links
<xsl:template match="phrase[@type = &quot;PERSON&quot;]">
    <a class="link-person">
        <xsl:attribute name="href">person:<xsl:value-of select="@topicid"/></xsl:attribute>
        <xsl:value-of select="."/>
    </a>
</xsl:template>
-->

<!-- Company Links - US Only for now.
    US: <phrase name="MSFT" type="COMPANY" vrtysux="COMPANY|MSFT">Microsoft</phrase>
    JP: <phrase name="6758.TO" type="COMPANY" vrtysux="COMPANY|6758.TO">Sony</phrase>
    International companies are ignored because there's no mapping of "TO" -> "JP" here.
-->

<!-- Old way: tappable links
<xsl:template match="phrase[@type = &quot;COMPANY&quot; and not(contains(@vrtysux, '.'))]">
    <a class="link-company">
        <xsl:attribute name="href">quote://<xsl:value-of select="substring-after(@vrtysux, '.')"/>/<xsl:value-of select="@name"/></xsl:attribute>
        <xsl:value-of select="."/>
    </a>
</xsl:template>
 -->

<!-- New way: ticker spans. We include some dummy text so the span occupies space onscreen.
    The "MMMM" prefix and suffix are to ensure a certain amount of em-widths are accomodated
    for in the span width layout calculations, with the @name playing a part in the overall
    length of it too.
-->

<!--
    Additional fun ensues because Methode doesn't include the company type in the markup. For example:
    Today <phrase>Microsoft</phrase> Corp. announced their earnings, which were lower than <phrase>Apple</phrase>'s.
    We want the ticker to go after the 'Corp.' and the apostrophe-s text.

    Mainsite does this via giant regex:

    https://github.dowjones.net/wsjdn-tesla/resp.svc.article/blob/93d577f6554721c687cfc6a666098c1d10405eaa/lib/article_html_formatter.js#L69

    We call a template giving it the next text
-->

<xsl:template match="phrase[@type = &quot;COMPANY&quot; and not(contains(@vrtysux, '.'))]">
    <xsl:value-of select="."/>
    <xsl:if test="following-sibling::node()/self::text()">
        <xsl:call-template name="split_company_extension">
            <xsl:with-param name="mode" select="'before'"/>
            <xsl:with-param name="text" select="following-sibling::node()" />
        </xsl:call-template>
    </xsl:if>
    <xsl:value-of select="' '"/>
    <span embed="ticker" class="ticker">
        <xsl:attribute name="id">ticker-<xsl:choose>
            <xsl:when test="contains(@vrtysux, '.')">
                <xsl:value-of select="substring-after(@vrtysux, '.')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="'US'"/>
            </xsl:otherwise>
        </xsl:choose>-<xsl:value-of select="@name"/></xsl:attribute>
        <xsl:value-of select="concat('MM', @name, 'MM')"/>
    </span>
    <xsl:value-of select="' '"/>
</xsl:template>

<xsl:template match="text()[local-name(preceding-sibling::node()[1]) = 'phrase' and preceding-sibling::node()[1][@type = &quot;COMPANY&quot;]]">
    <xsl:call-template name="split_company_extension">
        <xsl:with-param name="mode" select="'after'"/>
        <xsl:with-param name="text" select="." />
    </xsl:call-template>
</xsl:template>


<xsl:template match="media">
</xsl:template>

<xsl:template match="credit">
    <span class="credit"><xsl:value-of select="."/></span>
</xsl:template>

<xsl:template match="break">
    <break/>
</xsl:template>

<xsl:template match="subhed">
    <h2><xsl:value-of select="."/></h2>
</xsl:template>

<xsl:template match="small-hed">
    <h3><xsl:value-of select="."/></h3>
</xsl:template>

<xsl:template match="tagline">
    <p>
        <xsl:if test="not(following-sibling::p[position()=last()]) and not(following-sibling::tagline[position()=last()])">
            <xsl:attribute name="id">body-last-p</xsl:attribute>
        </xsl:if>
        <cite><xsl:value-of select="."/></cite>
        <xsl:if test="not(following-sibling::p[position()=last()]) and not(following-sibling::tagline[position()=last()])">
            <mark class="body-last-p-mark"/>
        </xsl:if>
    </p>
</xsl:template>

<xsl:template match="summary">
    <!-- TODO/REDO: generate-id(.) = generate-id(key('srcid', @src-id)) and -->
    <xsl:apply-templates select="*[self::summary-body or self::alt-summary-body]//image[@width &gt; 0 and @height &gt; 0]"/>
</xsl:template>

<xsl:template match="temporary-info">
</xsl:template>

<xsl:template name="image_src_id">
    <!-- this gets the last path component of a URL, or a filename if it's just a filename, recursively -->
    <xsl:param name="srcid" />
    <xsl:choose>
        <xsl:when test="contains($srcid, '/')">
            <xsl:call-template name="image_src_id">
                <xsl:with-param name="srcid" select="substring-after($srcid, '/')" />
            </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$srcid" />
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="nameloc_by_id">
    <xsl:param name="id" />
    <xsl:value-of select="//article//nameloc[@id = $id]/nmlist" />
</xsl:template>

<xsl:template name="get_file_name">
    <xsl:param name="input"/>
    <xsl:choose>
        <xsl:when test="contains($input, '/')">
            <xsl:call-template name="get_file_name">
                <xsl:with-param name="input" select="substring-after($input, '/')"/>
            </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$input"/>
        </xsl:otherwise>
    </xsl:choose>

</xsl:template>

<xsl:template match="image">
    <image>
        <xsl:attribute name="source">
            <xsl:call-template name="image_src_id">
                <xsl:with-param name="srcid" select="@src-id" />
            </xsl:call-template>
        </xsl:attribute>
        <xsl:attribute name="width">
            <xsl:value-of select="@width"/>
        </xsl:attribute>
        <xsl:attribute name="height">
            <xsl:value-of select="@height"/>
        </xsl:attribute>
    </image>
</xsl:template>

<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>


<xsl:template name="split_company_extension">
    <xsl:param name="text"/>
    <xsl:param name="mode"/>
    <xsl:variable name="length">
        <xsl:call-template name="company_extension_length">
            <xsl:with-param name="text" select="$text"/>
        </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
        <xsl:when test="$mode = 'before'">
            <xsl:value-of select="substring($text, 1, $length)"/>
        </xsl:when>
        <xsl:when test="$mode = 'after'">
            <xsl:value-of select="substring($text, 1 + $length)"/>
        </xsl:when>
    </xsl:choose>
</xsl:template>

<!--
    Find the first item in the extensions list that matches the start of $text and return the length of that item.
    Otherwise return zero.
-->

<xsl:template name="company_extension_length">
    <xsl:param name="text"/>
    <xsl:for-each select="document('')//dj:extensions/ext[. = substring($text, 1, string-length(.))]">
        <xsl:if test="position() = 1">
            <xsl:value-of select="string-length(.)" />
        </xsl:if>
    </xsl:for-each>
    <xsl:if test="not(document('')//dj:extensions/ext[. = substring($text, 1, string-length(.))])">0</xsl:if>
</xsl:template>

<!-- this list is derived from
    https://github.dowjones.net/wsjdn-tesla/resp.svc.article/blob/93d577f6554721c687cfc6a666098c1d10405eaa/lib/article_html_formatter.js#L69
-->
<dj:extensions>
    <ext>,</ext>
    <ext>.</ext>
    <ext>'S</ext>
    <ext>'s</ext>
    <ext> &amp; Co.</ext>

    <ext> Co.'s</ext>
    <ext> Co.,</ext>
    <ext> Co.</ext>

    <ext> PCL,</ext>
    <ext> SA,</ext>
    <ext> SA</ext>
    <ext> S.A.,</ext>
    <ext> S.A.</ext>
    <ext> AS,</ext>
    <ext> AS</ext>
    <ext> A.S.,</ext>
    <ext> A.S.</ext>
    <ext> AG</ext>

    <ext> Corp.'s</ext>
    <ext> Corp.,</ext>
    <ext> Corp.</ext>
    <ext> Corp's</ext>
    <ext> Corp,</ext>
    <ext> Corp</ext>

    <ext> Inc.'s</ext>
    <ext> Inc.,</ext>
    <ext> Inc.</ext>
    <ext> Inc's</ext>
    <ext> Inc,</ext>
    <ext> Inc</ext>

    <ext> Ltd.'s</ext>
    <ext> Ltd,</ext>
    <ext> Ltd.</ext>
    <ext> Ltd's</ext>
    <ext> Ltd,</ext>
    <ext> Ltd</ext>
</dj:extensions>

<xsl:template name="toupper">
  <xsl:param name="node" />
  <xsl:value-of select="translate($node, $smallcase, $uppercase)" />
</xsl:template>

<xsl:template name="tolower">
  <xsl:param name="node" />
  <xsl:value-of select="translate($node, $uppercase, $smallcase)" />
</xsl:template>

<!--Don't mind the variable names here- They don't entirely match the input format.  The comments show
     what the proper format actually is-->
<xsl:template name="formatDate">
    <xsl:param name="yyyy-mm-dd_HH_MM"/> <!--yyyy-mm-dd HH:MM -->
    <xsl:variable name="yyyy" select="substring-before($yyyy-mm-dd_HH_MM, '-')"/>
    <xsl:variable name="mm-dd_HH_MM" select="substring-after($yyyy-mm-dd_HH_MM, '-')"/> <!--mm-dd HH:MM -->
    <xsl:variable name="mm" select="substring-before($mm-dd_HH_MM, '-')"/>
    <xsl:variable name="dd_HH_MM" select="substring-after($mm-dd_HH_MM, '-')"/> <!--dd HH:MM -->
    <xsl:variable name="dd" select="substring-before($dd_HH_MM, ' ')"/>
    <xsl:variable name="HH_MM" select="substring-after($dd_HH_MM, ' ')"/> <!--HH:MM -->
    <xsl:variable name="HH" select="substring-before($HH_MM, ':')"/>
    <xsl:variable name="MM" select="substring-after($HH_MM, ':')"/> <!--MM -->
    <xsl:choose>
      <xsl:when test="$mm = '01'">January</xsl:when>
      <xsl:when test="$mm = '02'">February</xsl:when>
      <xsl:when test="$mm = '03'">March</xsl:when>
      <xsl:when test="$mm = '04'">April</xsl:when>
      <xsl:when test="$mm = '05'">May</xsl:when>
      <xsl:when test="$mm = '06'">June</xsl:when>
      <xsl:when test="$mm = '07'">July</xsl:when>
      <xsl:when test="$mm = '08'">August</xsl:when>
      <xsl:when test="$mm = '09'">September</xsl:when>
      <xsl:when test="$mm = '10'">October</xsl:when>
      <xsl:when test="$mm = '11'">November</xsl:when>
      <xsl:when test="$mm = '12'">December</xsl:when>
    </xsl:choose>
    <xsl:value-of select="' '"/>
    <xsl:value-of select="$dd"/>
    <xsl:value-of select="', '"/>
    <xsl:value-of select="$yyyy"/>
    <xsl:value-of select="' '"/>
    <xsl:choose>
        <xsl:when test="$HH &gt; 12">
            <xsl:value-of select="$HH - 12"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$HH"/>
        </xsl:otherwise>
    </xsl:choose>
    <xsl:value-of select="':'"/>
    <xsl:value-of select="$MM"/>
    <xsl:value-of select="' '"/>
    <xsl:choose>
        <xsl:when test="$HH &gt; 12">
            <xsl:value-of select="'p.m.'"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="'a.m.'"/>
        </xsl:otherwise>
    </xsl:choose>
    <xsl:value-of select="' ET'"/>
  </xsl:template>

</xsl:stylesheet>
