<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:output method="xml" encoding="UTF-8" indent="yes"/>
<xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
<xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>

<!-- 
This is the SEO-enabled version of wsj-itp-whatsnews-to-rss.xml. The main difference appears
to be that it allows the raw SEO URLs to go through to the XSLT, which means the XSLT URL resolver
must trap those calls and resolve them to the right DJML URLs.
-->

<!-- 
ITP What's News is an RSS containing a link to one or two DJML HTMLs. The DJML that represents
those HTMLs, in turn, contain a series of paragraphs. The paragraphs may link to other articles.
We convert this into an RSS feed. We require that all the DJML has been downloaded already,
including the linked-to articles, in order to process the PAID/FREE flags.
-->

<xsl:template match="/rss">
<rss version="2.0">
<channel>
<title>WSJ.com: ITP Whats News</title>
<description><xsl:value-of select="channel/title"/></description>
<xsl:for-each select="channel/item">
<xsl:comment>including:<xsl:value-of select="link"/></xsl:comment>
<xsl:call-template name="follow_djml">
<xsl:with-param name="filename">
<xsl:value-of select="link"/>
</xsl:with-param>
</xsl:call-template>
</xsl:for-each>
</channel>
</rss>
</xsl:template>

<xsl:template match="/article-doc">
<xsl:for-each select="article/article-body/p">
    <xsl:choose>
	<xsl:when test="link">
	<item>
	<title><xsl:value-of select="//article-doc/article/article-body/headline/main-hed"/></title>
	<description><xsl:value-of select="."/></description>
	<xsl:apply-templates select="link"/>
	</item>
	    </xsl:when>
		<xsl:otherwise>
		    <stub>
		    <title><xsl:value-of select="//article-doc/article/article-body/headline/main-hed"/></title>
		    <description><xsl:value-of select="."/></description>
			</stub>
			    </xsl:otherwise>
			        </xsl:choose>
				</xsl:for-each>
</xsl:template>

<xsl:template match="link">
<xsl:call-template name="process_link">
<xsl:with-param name="link">
<xsl:call-template name="nameloc_by_id">
<xsl:with-param name="id" select="@linkend"/>
</xsl:call-template>
</xsl:with-param>
</xsl:call-template>

</xsl:template>








<xsl:template name="process_link">
<xsl:param name="link"/>
<link>
  <xsl:value-of select="$link" />
</link>
<guid>
 <xsl:value-of select="substring-before(document( $link )/article-doc/@id, '.')" />
</guid>


<!-- Look for paid/free flag in the linked DJML:
<article-doc>
    <meta-data>
	<self-codes>
	    <code symbol="FREE" type="STATISTIC" vrtysux="STATISTIC|FREE"/>
	    -->
	    <category><xsl:choose>
	    <xsl:when test="document($link)/article-doc/meta-data/self-codes/code[@type = 'STATISTIC' and @symbol = 'FREE']">FREE</xsl:when>
	    <xsl:otherwise>PAID</xsl:otherwise>
	    </xsl:choose></category>
</xsl:template>

<xsl:template name="follow_djml">
<xsl:param name="filename"/>
<xsl:apply-templates select="document($filename)"/>
</xsl:template>

<xsl:template name="html_link_for_id">
<xsl:param name="id"/>
<!-- create http://online.wsj.com/article/SB10001424127887323823004578592100468591918.html given SB10001424127887323823004578592100468591918 -->
<xsl:call-template name="replace_string">
<xsl:with-param name="text"><xsl:value-of select="//article-doc/@url"/></xsl:with-param>
<xsl:with-param name="replace"><xsl:value-of select="substring-before(//article-doc/@id, '.')"/></xsl:with-param>
<xsl:with-param name="with"><xsl:value-of select="$id"/></xsl:with-param>
</xsl:call-template>
</xsl:template>

<xsl:template name="nameloc_by_id">
<xsl:param name="id"/>
<xsl:value-of select="//article//nameloc[@id = $id]/nmlist"/>
</xsl:template>

<xsl:template name="replace_string">
    <xsl:param name="text"/>
    <xsl:param name="replace"/>
    <xsl:param name="with"/>
    <xsl:choose>
      <xsl:when test="contains($text,$replace)">
        <xsl:value-of select="substring-before($text,$replace)"/>
        <xsl:value-of select="$with"/>
        <xsl:call-template name="replace_string">
          <xsl:with-param name="text" select="substring-after($text,$replace)"/>
          <xsl:with-param name="replace" select="$replace"/>
          <xsl:with-param name="with" select="$with"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>
